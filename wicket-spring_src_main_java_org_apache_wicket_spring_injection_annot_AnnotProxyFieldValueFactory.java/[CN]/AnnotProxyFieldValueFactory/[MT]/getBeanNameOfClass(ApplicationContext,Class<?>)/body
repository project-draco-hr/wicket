{
  List<String> names=new ArrayList<String>(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx,clazz)));
  if (ctx instanceof AbstractApplicationContext) {
    Iterator<String> it=names.iterator();
    while (it.hasNext()) {
      final String possibility=it.next();
      BeanDefinition beanDef=getBeanDefinition(((AbstractApplicationContext)ctx).getBeanFactory(),possibility);
      if (BeanFactoryUtils.isFactoryDereference(possibility) || possibility.startsWith("scopedTarget.") || (beanDef != null && !beanDef.isAutowireCandidate())) {
        it.remove();
      }
    }
  }
  if (names.isEmpty()) {
    throw new IllegalStateException("bean of type [" + clazz.getName() + "] not found");
  }
 else   if (names.size() > 1) {
    if (ctx instanceof AbstractApplicationContext) {
      List<String> primaries=new ArrayList<String>();
      for (      String name : names) {
        BeanDefinition beanDef=getBeanDefinition(((AbstractApplicationContext)ctx).getBeanFactory(),name);
        if (beanDef instanceof AbstractBeanDefinition) {
          if (beanDef.isPrimary()) {
            primaries.add(name);
          }
        }
      }
      if (primaries.size() == 1) {
        return primaries.get(0);
      }
    }
    StringBuilder msg=new StringBuilder();
    msg.append("More than one bean of type [");
    msg.append(clazz.getName());
    msg.append("] found, you have to specify the name of the bean ");
    msg.append("(@SpringBean(name=\"foo\")) in order to resolve this conflict. ");
    msg.append("Matched beans: ");
    msg.append(Strings.join(",",names.toArray(new String[names.size()])));
    throw new IllegalStateException(msg.toString());
  }
 else {
    return names.get(0);
  }
}
