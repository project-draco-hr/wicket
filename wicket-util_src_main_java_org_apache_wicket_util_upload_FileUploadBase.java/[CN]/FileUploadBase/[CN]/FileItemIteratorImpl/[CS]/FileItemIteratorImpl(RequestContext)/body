{
  if (ctx == null) {
    throw new NullPointerException("ctx parameter");
  }
  String contentType=ctx.getContentType();
  if ((null == contentType) || (!contentType.toLowerCase().startsWith(MULTIPART))) {
    throw new InvalidContentTypeException("the request doesn't contain a " + MULTIPART_FORM_DATA + " or "+ MULTIPART_MIXED+ " stream, content type header is "+ contentType);
  }
  InputStream input=ctx.getInputStream();
  if (sizeMax >= 0) {
    int requestSize=ctx.getContentLength();
    if (requestSize == -1) {
      input=new LimitedInputStream(input,sizeMax){
        @Override protected void raiseError(        final long pSizeMax,        final long pCount) throws IOException {
          FileUploadException ex=new SizeLimitExceededException("the request was rejected because" + " its size (" + pCount + ") exceeds the configured maximum"+ " ("+ pSizeMax+ ")",pCount,pSizeMax);
          throw new FileUploadIOException(ex);
        }
      }
;
    }
 else {
      if ((sizeMax >= 0) && (requestSize > sizeMax)) {
        throw new SizeLimitExceededException("the request was rejected because its size (" + requestSize + ") exceeds the configured maximum ("+ sizeMax+ ")",requestSize,sizeMax);
      }
    }
  }
  String charEncoding=headerEncoding;
  if (charEncoding == null) {
    charEncoding=ctx.getCharacterEncoding();
  }
  boundary=getBoundary(contentType);
  if (boundary == null) {
    throw new FileUploadException("the request was rejected because " + "no multipart boundary was found");
  }
  notifier=new MultipartFormInputStream.ProgressNotifier(listener,ctx.getContentLength());
  multi=new MultipartFormInputStream(input,boundary,notifier);
  multi.setHeaderEncoding(charEncoding);
  skipPreamble=true;
  findNextItem();
}
