{
  if (value == null) {
    throw new IllegalArgumentException("Value must not be null");
  }
  int hash=hash(key);
  Segment seg=segments[hash & SEGMENT_MASK];
  int segcount;
  Entry[] tab;
  int votes;
synchronized (seg) {
    tab=table;
    int index=hash & (tab.length - 1);
    Entry first=tab[index];
    for (Entry e=first; e != null; e=e.next) {
      if (e.hash == hash && eq(key,e.key)) {
        Object oldValue=e.value;
        e.value=value;
        return oldValue;
      }
    }
    Entry newEntry=new Entry(hash,key,value,first);
    tab[index]=newEntry;
    if ((segcount=++seg.count) < threshold)     return null;
    int bit=(1 << (hash & SEGMENT_MASK));
    votes=votesForResize;
    if ((votes & bit) == 0)     votes=votesForResize|=bit;
  }
  if (bitcount(votes) >= CONCURRENCY_LEVEL / 4 || segcount > (threshold * CONCURRENCY_LEVEL))   resize(0,tab);
  return null;
}
