{
  this.classId=classCounter++;
  this.clz=cls;
  if (cls.isPrimitive()) {
    fields=null;
    cons=null;
    writeObjectMethods=null;
    readObjectMethods=null;
    if (clz == boolean.class) {
      primitiveArray=new BooleanPrimitiveArray();
    }
 else     if (clz == byte.class) {
      primitiveArray=new BytePrimitiveArray();
    }
 else     if (clz == short.class) {
      primitiveArray=new ShortPrimitiveArray();
    }
 else     if (clz == char.class) {
      primitiveArray=new CharPrimitiveArray();
    }
 else     if (clz == int.class) {
      primitiveArray=new IntPrimitiveArray();
    }
 else     if (clz == long.class) {
      primitiveArray=new LongPrimitiveArray();
    }
 else     if (clz == float.class) {
      primitiveArray=new FloatPrimitiveArray();
    }
 else     if (clz == double.class) {
      primitiveArray=new DoublePrimitiveArray();
    }
 else {
      throw new RuntimeException("Unsupported primitive " + cls);
    }
  }
 else   if (cls.isInterface()) {
    fields=null;
    cons=null;
    writeObjectMethods=null;
    readObjectMethods=null;
    primitiveArray=null;
  }
 else {
    this.fields=new ArrayList();
    cons=getSerializableConstructor(clz);
    writeObjectMethods=new ArrayList();
    readObjectMethods=new ArrayList();
    primitiveArray=null;
    Class parent=cls;
    while (parent != Object.class) {
      Method method=getPrivateMethod(parent,"writeObject",new Class[]{ObjectOutputStream.class},Void.TYPE);
      if (method != null)       writeObjectMethods.add(method);
      method=getPrivateMethod(parent,"readObject",new Class[]{ObjectInputStream.class},Void.TYPE);
      if (method != null)       readObjectMethods.add(method);
      parent=parent.getSuperclass();
    }
    fillFields(cls);
  }
}
