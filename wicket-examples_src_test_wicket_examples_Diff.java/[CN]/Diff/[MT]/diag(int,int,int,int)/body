{
  final int[] fd=fdiag;
  final int[] bd=bdiag;
  final int[] xv=xvec;
  final int[] yv=yvec;
  final int dmin=xoff - ylim;
  final int dmax=xlim - yoff;
  final int fmid=xoff - yoff;
  final int bmid=xlim - ylim;
  int fmin=fmid, fmax=fmid;
  int bmin=bmid, bmax=bmid;
  final boolean odd=(fmid - bmid & 1) != 0;
  fd[fdiagoff + fmid]=xoff;
  bd[bdiagoff + bmid]=xlim;
  for (int c=1; ; ++c) {
    int d;
    boolean big_snake=false;
    if (fmin > dmin) {
      fd[fdiagoff + --fmin - 1]=-1;
    }
 else {
      ++fmin;
    }
    if (fmax < dmax) {
      fd[fdiagoff + ++fmax + 1]=-1;
    }
 else {
      --fmax;
    }
    for (d=fmax; d >= fmin; d-=2) {
      int x, y, oldx, tlo=fd[fdiagoff + d - 1], thi=fd[fdiagoff + d + 1];
      if (tlo >= thi) {
        x=tlo + 1;
      }
 else {
        x=thi;
      }
      oldx=x;
      y=x - d;
      while (x < xlim && y < ylim && xv[x] == yv[y]) {
        ++x;
        ++y;
      }
      if (x - oldx > 20) {
        big_snake=true;
      }
      fd[fdiagoff + d]=x;
      if (odd && bmin <= d && d <= bmax && bd[bdiagoff + d] <= fd[fdiagoff + d]) {
        cost=2 * c - 1;
        return d;
      }
    }
    if (bmin > dmin) {
      bd[bdiagoff + --bmin - 1]=Integer.MAX_VALUE;
    }
 else {
      ++bmin;
    }
    if (bmax < dmax) {
      bd[bdiagoff + ++bmax + 1]=Integer.MAX_VALUE;
    }
 else {
      --bmax;
    }
    for (d=bmax; d >= bmin; d-=2) {
      int x, y, oldx, tlo=bd[bdiagoff + d - 1], thi=bd[bdiagoff + d + 1];
      if (tlo < thi) {
        x=tlo;
      }
 else {
        x=thi - 1;
      }
      oldx=x;
      y=x - d;
      while (x > xoff && y > yoff && xv[x - 1] == yv[y - 1]) {
        --x;
        --y;
      }
      if (oldx - x > 20) {
        big_snake=true;
      }
      bd[bdiagoff + d]=x;
      if (!odd && fmin <= d && d <= fmax && bd[bdiagoff + d] <= fd[fdiagoff + d]) {
        cost=2 * c;
        return d;
      }
    }
    if (c > 200 && big_snake && heuristic) {
      int best=0;
      int bestpos=-1;
      for (d=fmax; d >= fmin; d-=2) {
        int dd=d - fmid;
        if ((fd[fdiagoff + d] - xoff) * 2 - dd > 12 * (c + (dd > 0 ? dd : -dd))) {
          if (fd[fdiagoff + d] * 2 - dd > best && fd[fdiagoff + d] - xoff > 20 && fd[fdiagoff + d] - d - yoff > 20) {
            int k;
            int x=fd[fdiagoff + d];
            for (k=1; k <= 20; k++) {
              if (xvec[x - k] != yvec[x - d - k]) {
                break;
              }
            }
            if (k == 21) {
              best=fd[fdiagoff + d] * 2 - dd;
              bestpos=d;
            }
          }
        }
      }
      if (best > 0) {
        cost=2 * c - 1;
        return bestpos;
      }
      best=0;
      for (d=bmax; d >= bmin; d-=2) {
        int dd=d - bmid;
        if ((xlim - bd[bdiagoff + d]) * 2 + dd > 12 * (c + (dd > 0 ? dd : -dd))) {
          if ((xlim - bd[bdiagoff + d]) * 2 + dd > best && xlim - bd[bdiagoff + d] > 20 && ylim - (bd[bdiagoff + d] - d) > 20) {
            int k;
            int x=bd[bdiagoff + d];
            for (k=0; k < 20; k++) {
              if (xvec[x + k] != yvec[x - d + k]) {
                break;
              }
            }
            if (k == 20) {
              best=(xlim - bd[bdiagoff + d]) * 2 + dd;
              bestpos=d;
            }
          }
        }
      }
      if (best > 0) {
        cost=2 * c - 1;
        return bestpos;
      }
    }
  }
}
