{
  final int extendIndex=requiresBaseMarkup(markup);
  if (extendIndex == -1) {
    return markup;
  }
  final Class<? extends MarkupContainer> markupClass=(Class<? extends MarkupContainer>)markup.getResource().getMarkupClass().getSuperclass();
  final IMarkup baseMarkup=this.markupCache.getMarkup(container,markupClass);
  if (baseMarkup == IMarkup.NO_MARKUP) {
    throw new MarkupNotFoundException("Base markup of inherited markup not found. Component class: " + markup.getResource().getContainerInfo().getContainerClass().getName() + " Enable debug messages for wicket.util.resource.Resource to get a list of all filenames tried.");
  }
  this.markupCache.addAfterLoadListener(baseMarkup.getResource(),new IChangeListener(){
    public void onChange(){
      if (log.isDebugEnabled()) {
        log.debug("Remove derived markup from cache: " + markup.getResource());
      }
      InheritedMarkupMarkupLoader.this.markupCache.removeMarkup(markup.getResource());
    }
    /** 
 * Make sure there is only one listener per derived markup
 * @see java.lang.Object#equals(java.lang.Object)
 */
    @Override public boolean equals(    final Object obj){
      return true;
    }
    /** 
 * Make sure there is only one listener per derived markup
 * @see java.lang.Object#hashCode()
 */
    @Override public int hashCode(){
      return markup.getResource().getCacheKey().hashCode();
    }
  }
);
  final IMarkup mergedMarkup=mergedMarkup(markup,baseMarkup,extendIndex);
  return mergedMarkup;
}
